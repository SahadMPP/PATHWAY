// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'student_chat_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$StudentChatEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() givingValue,
    required TResult Function(String image, String name, BuildContext context)
        navigatingToChatScreen,
    required TResult Function(String textValue) filteringForSearch,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? givingValue,
    TResult? Function(String image, String name, BuildContext context)?
        navigatingToChatScreen,
    TResult? Function(String textValue)? filteringForSearch,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? givingValue,
    TResult Function(String image, String name, BuildContext context)?
        navigatingToChatScreen,
    TResult Function(String textValue)? filteringForSearch,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_givingValue value) givingValue,
    required TResult Function(_navigatingToChatScreen value)
        navigatingToChatScreen,
    required TResult Function(_filteringForSearch value) filteringForSearch,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_givingValue value)? givingValue,
    TResult? Function(_navigatingToChatScreen value)? navigatingToChatScreen,
    TResult? Function(_filteringForSearch value)? filteringForSearch,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_givingValue value)? givingValue,
    TResult Function(_navigatingToChatScreen value)? navigatingToChatScreen,
    TResult Function(_filteringForSearch value)? filteringForSearch,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StudentChatEventCopyWith<$Res> {
  factory $StudentChatEventCopyWith(
          StudentChatEvent value, $Res Function(StudentChatEvent) then) =
      _$StudentChatEventCopyWithImpl<$Res, StudentChatEvent>;
}

/// @nodoc
class _$StudentChatEventCopyWithImpl<$Res, $Val extends StudentChatEvent>
    implements $StudentChatEventCopyWith<$Res> {
  _$StudentChatEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$givingValueImplCopyWith<$Res> {
  factory _$$givingValueImplCopyWith(
          _$givingValueImpl value, $Res Function(_$givingValueImpl) then) =
      __$$givingValueImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$givingValueImplCopyWithImpl<$Res>
    extends _$StudentChatEventCopyWithImpl<$Res, _$givingValueImpl>
    implements _$$givingValueImplCopyWith<$Res> {
  __$$givingValueImplCopyWithImpl(
      _$givingValueImpl _value, $Res Function(_$givingValueImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$givingValueImpl implements _givingValue {
  const _$givingValueImpl();

  @override
  String toString() {
    return 'StudentChatEvent.givingValue()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$givingValueImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() givingValue,
    required TResult Function(String image, String name, BuildContext context)
        navigatingToChatScreen,
    required TResult Function(String textValue) filteringForSearch,
  }) {
    return givingValue();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? givingValue,
    TResult? Function(String image, String name, BuildContext context)?
        navigatingToChatScreen,
    TResult? Function(String textValue)? filteringForSearch,
  }) {
    return givingValue?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? givingValue,
    TResult Function(String image, String name, BuildContext context)?
        navigatingToChatScreen,
    TResult Function(String textValue)? filteringForSearch,
    required TResult orElse(),
  }) {
    if (givingValue != null) {
      return givingValue();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_givingValue value) givingValue,
    required TResult Function(_navigatingToChatScreen value)
        navigatingToChatScreen,
    required TResult Function(_filteringForSearch value) filteringForSearch,
  }) {
    return givingValue(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_givingValue value)? givingValue,
    TResult? Function(_navigatingToChatScreen value)? navigatingToChatScreen,
    TResult? Function(_filteringForSearch value)? filteringForSearch,
  }) {
    return givingValue?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_givingValue value)? givingValue,
    TResult Function(_navigatingToChatScreen value)? navigatingToChatScreen,
    TResult Function(_filteringForSearch value)? filteringForSearch,
    required TResult orElse(),
  }) {
    if (givingValue != null) {
      return givingValue(this);
    }
    return orElse();
  }
}

abstract class _givingValue implements StudentChatEvent {
  const factory _givingValue() = _$givingValueImpl;
}

/// @nodoc
abstract class _$$navigatingToChatScreenImplCopyWith<$Res> {
  factory _$$navigatingToChatScreenImplCopyWith(
          _$navigatingToChatScreenImpl value,
          $Res Function(_$navigatingToChatScreenImpl) then) =
      __$$navigatingToChatScreenImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String image, String name, BuildContext context});
}

/// @nodoc
class __$$navigatingToChatScreenImplCopyWithImpl<$Res>
    extends _$StudentChatEventCopyWithImpl<$Res, _$navigatingToChatScreenImpl>
    implements _$$navigatingToChatScreenImplCopyWith<$Res> {
  __$$navigatingToChatScreenImplCopyWithImpl(
      _$navigatingToChatScreenImpl _value,
      $Res Function(_$navigatingToChatScreenImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? image = null,
    Object? name = null,
    Object? context = null,
  }) {
    return _then(_$navigatingToChatScreenImpl(
      image: null == image
          ? _value.image
          : image // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      context: null == context
          ? _value.context
          : context // ignore: cast_nullable_to_non_nullable
              as BuildContext,
    ));
  }
}

/// @nodoc

class _$navigatingToChatScreenImpl implements _navigatingToChatScreen {
  const _$navigatingToChatScreenImpl(
      {required this.image, required this.name, required this.context});

  @override
  final String image;
  @override
  final String name;
  @override
  final BuildContext context;

  @override
  String toString() {
    return 'StudentChatEvent.navigatingToChatScreen(image: $image, name: $name, context: $context)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$navigatingToChatScreenImpl &&
            (identical(other.image, image) || other.image == image) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.context, context) || other.context == context));
  }

  @override
  int get hashCode => Object.hash(runtimeType, image, name, context);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$navigatingToChatScreenImplCopyWith<_$navigatingToChatScreenImpl>
      get copyWith => __$$navigatingToChatScreenImplCopyWithImpl<
          _$navigatingToChatScreenImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() givingValue,
    required TResult Function(String image, String name, BuildContext context)
        navigatingToChatScreen,
    required TResult Function(String textValue) filteringForSearch,
  }) {
    return navigatingToChatScreen(image, name, context);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? givingValue,
    TResult? Function(String image, String name, BuildContext context)?
        navigatingToChatScreen,
    TResult? Function(String textValue)? filteringForSearch,
  }) {
    return navigatingToChatScreen?.call(image, name, context);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? givingValue,
    TResult Function(String image, String name, BuildContext context)?
        navigatingToChatScreen,
    TResult Function(String textValue)? filteringForSearch,
    required TResult orElse(),
  }) {
    if (navigatingToChatScreen != null) {
      return navigatingToChatScreen(image, name, context);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_givingValue value) givingValue,
    required TResult Function(_navigatingToChatScreen value)
        navigatingToChatScreen,
    required TResult Function(_filteringForSearch value) filteringForSearch,
  }) {
    return navigatingToChatScreen(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_givingValue value)? givingValue,
    TResult? Function(_navigatingToChatScreen value)? navigatingToChatScreen,
    TResult? Function(_filteringForSearch value)? filteringForSearch,
  }) {
    return navigatingToChatScreen?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_givingValue value)? givingValue,
    TResult Function(_navigatingToChatScreen value)? navigatingToChatScreen,
    TResult Function(_filteringForSearch value)? filteringForSearch,
    required TResult orElse(),
  }) {
    if (navigatingToChatScreen != null) {
      return navigatingToChatScreen(this);
    }
    return orElse();
  }
}

abstract class _navigatingToChatScreen implements StudentChatEvent {
  const factory _navigatingToChatScreen(
      {required final String image,
      required final String name,
      required final BuildContext context}) = _$navigatingToChatScreenImpl;

  String get image;
  String get name;
  BuildContext get context;
  @JsonKey(ignore: true)
  _$$navigatingToChatScreenImplCopyWith<_$navigatingToChatScreenImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$filteringForSearchImplCopyWith<$Res> {
  factory _$$filteringForSearchImplCopyWith(_$filteringForSearchImpl value,
          $Res Function(_$filteringForSearchImpl) then) =
      __$$filteringForSearchImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String textValue});
}

/// @nodoc
class __$$filteringForSearchImplCopyWithImpl<$Res>
    extends _$StudentChatEventCopyWithImpl<$Res, _$filteringForSearchImpl>
    implements _$$filteringForSearchImplCopyWith<$Res> {
  __$$filteringForSearchImplCopyWithImpl(_$filteringForSearchImpl _value,
      $Res Function(_$filteringForSearchImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? textValue = null,
  }) {
    return _then(_$filteringForSearchImpl(
      textValue: null == textValue
          ? _value.textValue
          : textValue // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$filteringForSearchImpl implements _filteringForSearch {
  const _$filteringForSearchImpl({required this.textValue});

  @override
  final String textValue;

  @override
  String toString() {
    return 'StudentChatEvent.filteringForSearch(textValue: $textValue)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$filteringForSearchImpl &&
            (identical(other.textValue, textValue) ||
                other.textValue == textValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, textValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$filteringForSearchImplCopyWith<_$filteringForSearchImpl> get copyWith =>
      __$$filteringForSearchImplCopyWithImpl<_$filteringForSearchImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() givingValue,
    required TResult Function(String image, String name, BuildContext context)
        navigatingToChatScreen,
    required TResult Function(String textValue) filteringForSearch,
  }) {
    return filteringForSearch(textValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? givingValue,
    TResult? Function(String image, String name, BuildContext context)?
        navigatingToChatScreen,
    TResult? Function(String textValue)? filteringForSearch,
  }) {
    return filteringForSearch?.call(textValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? givingValue,
    TResult Function(String image, String name, BuildContext context)?
        navigatingToChatScreen,
    TResult Function(String textValue)? filteringForSearch,
    required TResult orElse(),
  }) {
    if (filteringForSearch != null) {
      return filteringForSearch(textValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_givingValue value) givingValue,
    required TResult Function(_navigatingToChatScreen value)
        navigatingToChatScreen,
    required TResult Function(_filteringForSearch value) filteringForSearch,
  }) {
    return filteringForSearch(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_givingValue value)? givingValue,
    TResult? Function(_navigatingToChatScreen value)? navigatingToChatScreen,
    TResult? Function(_filteringForSearch value)? filteringForSearch,
  }) {
    return filteringForSearch?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_givingValue value)? givingValue,
    TResult Function(_navigatingToChatScreen value)? navigatingToChatScreen,
    TResult Function(_filteringForSearch value)? filteringForSearch,
    required TResult orElse(),
  }) {
    if (filteringForSearch != null) {
      return filteringForSearch(this);
    }
    return orElse();
  }
}

abstract class _filteringForSearch implements StudentChatEvent {
  const factory _filteringForSearch({required final String textValue}) =
      _$filteringForSearchImpl;

  String get textValue;
  @JsonKey(ignore: true)
  _$$filteringForSearchImplCopyWith<_$filteringForSearchImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$StudentChatState {
  List<Teacher> get list => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $StudentChatStateCopyWith<StudentChatState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StudentChatStateCopyWith<$Res> {
  factory $StudentChatStateCopyWith(
          StudentChatState value, $Res Function(StudentChatState) then) =
      _$StudentChatStateCopyWithImpl<$Res, StudentChatState>;
  @useResult
  $Res call({List<Teacher> list});
}

/// @nodoc
class _$StudentChatStateCopyWithImpl<$Res, $Val extends StudentChatState>
    implements $StudentChatStateCopyWith<$Res> {
  _$StudentChatStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? list = null,
  }) {
    return _then(_value.copyWith(
      list: null == list
          ? _value.list
          : list // ignore: cast_nullable_to_non_nullable
              as List<Teacher>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$StudentChatStateImplCopyWith<$Res>
    implements $StudentChatStateCopyWith<$Res> {
  factory _$$StudentChatStateImplCopyWith(_$StudentChatStateImpl value,
          $Res Function(_$StudentChatStateImpl) then) =
      __$$StudentChatStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<Teacher> list});
}

/// @nodoc
class __$$StudentChatStateImplCopyWithImpl<$Res>
    extends _$StudentChatStateCopyWithImpl<$Res, _$StudentChatStateImpl>
    implements _$$StudentChatStateImplCopyWith<$Res> {
  __$$StudentChatStateImplCopyWithImpl(_$StudentChatStateImpl _value,
      $Res Function(_$StudentChatStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? list = null,
  }) {
    return _then(_$StudentChatStateImpl(
      list: null == list
          ? _value._list
          : list // ignore: cast_nullable_to_non_nullable
              as List<Teacher>,
    ));
  }
}

/// @nodoc

class _$StudentChatStateImpl implements _StudentChatState {
  const _$StudentChatStateImpl({required final List<Teacher> list})
      : _list = list;

  final List<Teacher> _list;
  @override
  List<Teacher> get list {
    if (_list is EqualUnmodifiableListView) return _list;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_list);
  }

  @override
  String toString() {
    return 'StudentChatState(list: $list)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StudentChatStateImpl &&
            const DeepCollectionEquality().equals(other._list, _list));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_list));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$StudentChatStateImplCopyWith<_$StudentChatStateImpl> get copyWith =>
      __$$StudentChatStateImplCopyWithImpl<_$StudentChatStateImpl>(
          this, _$identity);
}

abstract class _StudentChatState implements StudentChatState {
  const factory _StudentChatState({required final List<Teacher> list}) =
      _$StudentChatStateImpl;

  @override
  List<Teacher> get list;
  @override
  @JsonKey(ignore: true)
  _$$StudentChatStateImplCopyWith<_$StudentChatStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
